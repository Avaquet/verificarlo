#!/usr/bin/env python3

import numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
from tabulate import tabulate
import random
import math
import sys
import struct
import shlex
import os.path
import subprocess
import threading
from os import listdir

# file used for profile, and input
profile_name = "vfc_profile.txt"
config_name_args = "vfc_config_args.txt"
config_name_ops = "vfc_config_ops.txt"
config_name_all = "vfc_config_all.txt"
output_dir_args = ["vfc_args_ref", "vfc_args_std"]
output_dir_ops = ["vfc_ops_ref", "vfc_ops_std"]
output_dir_all = ["vfc_all_ref", "vfc_all_std"]
ArgumentsFrame = pd.DataFrame()
FunctionsFrame = pd.DataFrame()
ArgumentsIndex = []
FunctionsIndex = []
runPath = ""
cmpPath = ""
OperationsResults = pd.DataFrame()
ArgumentsResults = pd.DataFrame()
BothResults = [pd.DataFrame(), pd.DataFrame()]
N = 8000
M = 100
C = 0.09


def set_environment_variable(envVar, value, env):
	#replace current value, if the environment variable already exists
	env[envVar.strip()] = value.strip()

	return env

def unset_environment_variable(envVar, env):
	#replace current value, if the environment variable already exists
	del env[envVar.strip()]

	return env


def add_environment_variable(envVar, value, env):
	#check if the environment variable already exists, then append or add the new value
	if (envVar.strip() in env):
		env[envVar.strip()] = value + ":" + env[envVar.strip()]
	else:
		env[envVar.strip()] = value.strip()

	return env


def shell(cmd, newEnv):
	env = None
	if (newEnv is None):
		env = os.environ.copy()
	else:
		env = newEnv

	cmdNew = ""
	cmdSplit = shlex.split(cmd)
	for cmdEntry in cmdSplit:
		cmdNew = cmdNew + " " + cmdEntry.strip()

	proc = subprocess.Popen(cmdNew.split(), stdout=subprocess.PIPE, 
		stderr=subprocess.PIPE, universal_newlines=True, env=env)

	try:
		proc.communicate(timeout = 5)
	except subprocess.TimeoutExpired:
		proc.kill()
		return 1

	proc.wait()

	return proc.returncode


def run(script, output_dir, env):
	# create the runing command
	command = "./" + script + " " + output_dir

	return_code = shell(command, env)

	if return_code != 0:
		print("Error during run, return code = Â {}".format(return_code))

	return return_code

def cmp(script, reference_dir, current_dir, env):
	# create the comparison command
	command = "./" + script + " " + reference_dir + " " + current_dir

	return (shell(command, env) == 0)

def getProfile(file):
	# get informations from profile file
	if not os.path.isfile(file):
		print("error profile file not found")
		exit()

	f = open(file, 'r')
	Lines = f.readlines()

	Functions = []
	Arguments = []

	i = 0
	while i < len(Lines):
		ID, Lib, Int, Float, Double, Prec64, Range64, \
		Prec32, Range32, Ninputs, Noutputs, Ncalls = Lines[i].split()

		Lib = int(Lib)
		Int = int(Int)
		Float = int(Float)
		Double = int(Double)
		Prec64 = int(Prec64)
		Range64 = int(Range64)
		Prec32 = int(Prec32)
		Range32 = int(Range32)
		Ninputs = int(Ninputs)
		Noutputs = int(Noutputs)
		Ncalls = int(Ncalls)

		thisFunction = [ ID, Lib, Int, Float, Double, Prec64, Range64, 
						Prec32, Range32, Ninputs, Noutputs, Ncalls]

		Functions.append(thisFunction)

		j = i + 1
		while j < i + Ninputs + Noutputs + 1:
			IO, Type, Prec, Range = Lines[j].split()

			Type = int(Type)
			Prec = int(Prec)
			Range = int(Range)

			functionArgs = [ID, Lib, Int, IO, Type, Prec, Range, Ncalls]

			Arguments.append(functionArgs)

			j = j + 1

		i = i + Ninputs + Noutputs + 1

	FunctionsFrame = 	pd.DataFrame(Functions, 
						columns = [	'ID', 'Lib','Int','Float','Double','Prec64',
						'Range64','Prec32','Range32','Ninputs','Noutputs','Ncalls']) 

	FunctionsFilter = FunctionsFrame.copy()
	FunctionsFilter = FunctionsFilter[(FunctionsFilter['Lib'] == 0) & (FunctionsFilter['Int'] == 0)]

	ArgumentsFrame =  	pd.DataFrame(Arguments, 
						columns = [	'ID', 'Lib', 'Int', 'IO','Type','Prec','Range', 'Ncalls']) 

	ArgumentsFilter = ArgumentsFrame.copy()
	ArgumentsFilter = ArgumentsFilter[(ArgumentsFilter['Lib'] == 1) | (ArgumentsFilter['Int'] == 1)] 

	f.close()

	return FunctionsFrame, FunctionsFilter.index, ArgumentsFrame, ArgumentsFilter.index

def save(Arguments, Operations, File):
	f = open(File, 'w')

	arg_index = 0

	for i in Operations.index:
		f.write("{ID}\t{Lib}\t{Int}\t{Float}\t{Double}\t{Prec64}\t{Range64}\t{Prec32}\t{Range32}\t{Ninputs}\t{Noutputs}\t{Ncalls}\n".format(
				ID = Operations.at[i, "ID"], 
				Lib = Operations.at[i, "Lib"],
				Int = Operations.at[i, "Int"],
				Float = Operations.at[i, "Float"],
				Double = Operations.at[i, "Double"],
				Prec64 = Operations.at[i, "Prec64"],
				Range64 = Operations.at[i, "Range64"],
				Prec32 = Operations.at[i, "Prec32"], 
				Range32 = Operations.at[i, "Range32"],
				Ninputs = Operations.at[i, "Ninputs"],
				Noutputs = Operations.at[i, "Noutputs"],
				Ncalls = Operations.at[i, "Ncalls"]))

		j = arg_index
		while j < arg_index + Operations.at[i, "Ninputs"] + Operations.at[i, "Noutputs"]:
			f.write("{IO}\t{Type}\t{Prec}\t{Range}\n".format(
					IO = Arguments.at[j, 'IO'],
					Type = Arguments.at[j, 'Type'],
					Prec = Arguments.at[j, 'Prec'],
					Range = Arguments.at[j, 'Range']))
			j = j + 1
		arg_index = j

	f.close()

def Check(runPath, cmpPath, reference_dir, current_dir, config_file, env, Arguments, Operations):
	save(Arguments, Operations, config_file)

	run(runPath, current_dir, env)

	return cmp(cmpPath, reference_dir, current_dir, env)


def Energy(Arguments, ArgumentsIndex, Operations, OperationsIndex):
	E = 0

	# Arguments
	for i in ArgumentsIndex:
		V = 0
		if Arguments.at[i, "Type"] == 1:
			V = (Arguments.at[i, "Prec"] + Arguments.at[i, "Range"])/63.0
		else:
			V = (Arguments.at[i, "Prec"] + Arguments.at[i, "Range"])/31.0
		E += Arguments.at[i, "Ncalls"] * V

	#Operations
	for i in OperationsIndex:
		if Operations.at[i, "Float"] != 0:
			V = ((Operations.at[i, "Prec32"] + Operations.at[i, "Range32"])/31.0)
			E += V * Operations.at[i, "Ncalls"]
		if Operations.at[i, "Double"] != 0:
			V = ((Operations.at[i, "Prec64"] + Operations.at[i, "Range64"])/63.0)
			E += V * Operations.at[i, "Ncalls"]
	return E

def ModifyArgs(Arguments, ArgumentsIndex):
	Copy = Arguments.copy()

	i = random.choice(ArgumentsIndex)

	A = ["Prec", "Range"]
	B = [[23, 8], [52, 11]]

	j = random.randrange(0,2)

	if random.randrange(0,3) == 0 and Copy.at[i, A[j]] != B[Copy["Type"][i]][j]:
		Copy.at[i, A[j]] = random.randrange(Copy.at[i, A[j]]+1, B[Copy["Type"][i]][j]+1)
	elif Copy.at[i, A[j]] != 1:
		Copy.at[i, A[j]] = random.randrange(1, Copy.at[i, A[j]])

	return Copy

def ModifyOps(Operations, OperationsIndex):
	Copy = Operations.copy()

	i = random.choice(OperationsIndex)

	A = ["Prec32", "Range32", "Prec64", "Range64"]
	B = [23, 8, 52, 11]

	j = random.randrange(0,4)

	if random.randrange(0,3) == 0 and Copy.at[i, A[j]] != B[j]:
		Copy.at[i, A[j]] = random.randrange(Copy.at[i, A[j]]+1, B[j]+1)
	elif Copy.at[i, A[j]] != 1:
		Copy.at[i, A[j]] = random.randrange(1, Copy.at[i, A[j]])
	

	return Copy


def sigmoid(x, a, b, c, d):
	return ((a - b) / (1. + np.exp(x - (c / 2)) ** d)) + b

def SA_Arguments():
	ProbabiltyList = []
	EnergyList = []
	TemperatureList = []

	# set backend
	set_environment_variable("VFC_BACKENDS", "libinterflop_vprec.so --prec-input-file={} --instrument=arguments".format(config_name_args), env)

	S = ArgumentsFrame.copy()
	E = Energy(S, ArgumentsIndex, FunctionsFrame, FunctionsIndex)
	P = 1
	Step = M/N

	i = 0
	cpt = 0
	while i < M:
		T = sigmoid(i, 1.0, 0.0, M, C)
		# modify state
		Stmp = ModifyArgs(S, ArgumentsIndex)

		# compute state energy
		Etmp = Energy(Stmp, ArgumentsIndex, FunctionsFrame, FunctionsIndex)

		# test state
		Flag = Check(runPath, cmpPath, output_dir_args[0], output_dir_args[1], config_name_args, env, Stmp, FunctionsFrame)

		# choose if test if accepted
		if Flag:
			DeltaE = (E - Etmp) * 0.1
			if DeltaE >= 0:
				S, E = Stmp, Etmp
			else:
				try:
					P = math.exp(DeltaE/T)
				except OverflowError:
					P = 0
				if random.uniform(0, 1) < P:
					S, E = Stmp, Etmp
			if cpt % (N/100) == 0:
				print("Arguments \t-> {}/{}".format(cpt, N, round(T,2), round(E,2)))
			i = i + Step
			cpt = cpt + 1

		ProbabiltyList.append(P)
		EnergyList.append(E)
		TemperatureList.append(T)

	S.to_csv("vfc_exp_data/ArgumentsResults.csv")

	fig = plt.figure(1, figsize=(24, 14))
	ax1, ax2, ax3 = fig.subplots(1, 3, sharex=True)
	ax1.plot(ProbabiltyList)
	ax2.plot(EnergyList)
	ax3.plot(TemperatureList)

	ax1.set_ylabel("Probabilty")
	ax1.set_xlabel("Iteration")
	ax2.set_ylabel("System Energy")
	ax2.set_xlabel("Iteration")
	ax3.set_ylabel("Temperature")
	ax3.set_xlabel("Iteration")

	ax1.set_title("Evolution of the Probabilty during execution")
	ax2.set_title("Evolution of the Energy during execution")
	ax3.set_title("Evolution of the Temperature during execution")
	plt.savefig("vfc_exp_data/vfc_args_only.svg", format='svg')
	plt.clf()


def SA_Operations():
	ProbabiltyList = []
	EnergyList = []
	TemperatureList = []

	# set backend
	set_environment_variable("VFC_BACKENDS", "libinterflop_vprec.so --prec-input-file={} --instrument=operations".format(config_name_ops), env)

	S = FunctionsFrame.copy()
	E = Energy(ArgumentsFrame, ArgumentsIndex, S, FunctionsIndex)
	P = 1
	Step = M/N
	
	i = 0
	cpt = 0
	while i < M:
		T = sigmoid(i, 1.0, 0.0, M, C)
		# modify state
		Stmp = ModifyOps(S, FunctionsIndex)

		# compute state energy
		Etmp = Energy(ArgumentsFrame, ArgumentsIndex, Stmp, FunctionsIndex)

		# test state
		Flag = Check(runPath, cmpPath, output_dir_ops[0], output_dir_ops[1], config_name_ops, env, ArgumentsFrame, Stmp)

		# choose if test if accepted
		if Flag:
			DeltaE = (E - Etmp) * 0.1
			if DeltaE >= 0:
				S, E = Stmp, Etmp
			else:
				try:
					P = math.exp(DeltaE/T)
				except OverflowError:
					P = 0
				if random.uniform(0, 1) < P:
					S, E = Stmp, Etmp
			if cpt % (N/100) == 0:
				print("Operations \t-> {}/{}".format(cpt, N, round(T,2), round(E,2)))
			i = i + Step
			cpt = cpt + 1
		
		ProbabiltyList.append(P)
		EnergyList.append(E)
		TemperatureList.append(T)

	S.to_csv("vfc_exp_data/OperationsResults.csv")

	fig = plt.figure(1, figsize=(24, 14))
	ax1, ax2, ax3 = fig.subplots(1, 3, sharex=True)
	ax1.plot(ProbabiltyList)
	ax2.plot(EnergyList)
	ax3.plot(TemperatureList)

	ax1.set_ylabel("Probabilty")
	ax1.set_xlabel("Iteration")
	ax2.set_ylabel("System Energy")
	ax2.set_xlabel("Iteration")
	ax3.set_ylabel("Temperature")
	ax3.set_xlabel("Iteration")

	ax1.set_title("Evolution of the Probabilty during execution")
	ax2.set_title("Evolution of the Energy during execution")
	ax3.set_title("Evolution of the Temperature during execution")
	plt.savefig("vfc_exp_data/vfc_ops_only.svg", format='svg')
	plt.clf()

def SA_All():
	ProbabiltyList = []
	EnergyList = []
	TemperatureList = []

	# set backend
	set_environment_variable("VFC_BACKENDS", "libinterflop_vprec.so --prec-input-file={} --instrument=all".format(config_name_all), env)

	S = [ArgumentsFrame.copy(), FunctionsFrame.copy()]
	E = Energy(S[0], ArgumentsIndex, S[1], FunctionsIndex)
	P = 1
	Step = M/N
	
	i = 0
	cpt = 0
	while i < M:
		T = sigmoid(i, 1.0, 0.0, M, C)
		# modify state
		Stmp = [S[0], S[1]]
		if random.choice([0, 1]):
			Stmp[0] = ModifyArgs(S[0], ArgumentsIndex)
		else:
			Stmp[1] = ModifyOps(S[1], FunctionsIndex)

		# compute state energy
		Etmp = Energy(Stmp[0], ArgumentsIndex, Stmp[1], FunctionsIndex)

		# test state
		Flag = Check(runPath, cmpPath, output_dir_all[0], output_dir_all[1], config_name_all, env, Stmp[0], Stmp[1])

		# choose if test if accepted
		if Flag:
			DeltaE = (E - Etmp) * 0.1
			if DeltaE >= 0:
				S, E = Stmp, Etmp
			else:
				try:
					P = math.exp(DeltaE/T)
				except OverflowError:
					P = 0
				if random.uniform(0, 1) < P:
					S, E = Stmp, Etmp
			if cpt % (N/100) == 0:
				print("All \t\t-> {}/{}".format(cpt, N, round(T,2), round(E,2)))
			i = i + Step
			cpt = cpt + 1

		ProbabiltyList.append(P)
		EnergyList.append(E)
		TemperatureList.append(T)

	S[0].to_csv("vfc_exp_data/BothArgsResults.csv")
	S[1].to_csv("vfc_exp_data/BothOpsResults.csv")

	fig = plt.figure(1, figsize=(24, 14))
	ax1, ax2, ax3 = fig.subplots(1, 3, sharex=True)
	ax1.plot(ProbabiltyList)
	ax2.plot(EnergyList)
	ax3.plot(TemperatureList)

	ax1.set_ylabel("Probabilty")
	ax1.set_xlabel("Iteration")
	ax2.set_ylabel("System Energy")
	ax2.set_xlabel("Iteration")
	ax3.set_ylabel("Temperature")
	ax3.set_xlabel("Iteration")

	ax1.set_title("Evolution of the Probabilty during execution")
	ax2.set_title("Evolution of the Energy during execution")
	ax3.set_title("Evolution of the Temperature during execution")
	plt.savefig("vfc_exp_data/vfc_args_ops.svg", format='svg')
	plt.clf()

if __name__ == "__main__":

	if len(sys.argv) < 3:
		print("vfc_precexp [exrun] [excmp]")
		exit()

	runPath = sys.argv[1]
	cmpPath = sys.argv[2]

	if not os.path.exists(runPath):
		print("runing script not found")
		exit(0)

	if not os.path.exists(cmpPath):
		print("comparison scirpt not found")
		exit(0)

	if not os.access(runPath, os.X_OK):
		print("runing scirpt is not executable")
		exit(0)

	if not os.access(cmpPath, os.X_OK):
		print("comparison scirpt is not executable")
		exit(0)

	if not os.path.isdir("./exp_ref_output"):
		os.mkdir("./exp_ref_output")

	if not os.path.isdir(output_dir_args[0]):
		os.mkdir(output_dir_args[0])

	if not os.path.isdir(output_dir_args[1]):
		os.mkdir(output_dir_args[1])

	if not os.path.isdir(output_dir_ops[0]):
		os.mkdir(output_dir_ops[0])

	if not os.path.isdir(output_dir_ops[1]):
		os.mkdir(output_dir_ops[1])

	if not os.path.isdir(output_dir_all[0]):
		os.mkdir(output_dir_all[0])

	if not os.path.isdir(output_dir_all[1]):
		os.mkdir(output_dir_all[1])

	env = os.environ.copy()

	#########################################
	#  				Profile Run 			#
	#########################################
	# unset input file
	if "VFC_PREC_INPUT" in env:
		unset_environment_variable("VFC_PREC_INPUT", env)

	# set backend
	set_environment_variable("VFC_BACKENDS", "libinterflop_vprec.so --prec-output-file={}".format(profile_name), env)

	# run to create profile file
	run(runPath, output_dir_args[0], env)
	run(runPath, output_dir_ops[0], env)
	run(runPath, output_dir_all[0], env)

	# get dataset
	FunctionsFrame, FunctionsIndex, ArgumentsFrame, ArgumentsIndex = getProfile(profile_name)

	t1 = threading.Thread(target=SA_Arguments)
	t2 = threading.Thread(target=SA_Operations)
	t3 = threading.Thread(target=SA_All)

	t1.start()
	t2.start()
	t3.start()

	t1.join()
	t2.join()
	t3.join()
