#!/usr/bin/python

from __future__ import print_function

import argparse
import os
import sys
import subprocess

PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))
libvfcinstrument = PROJECT_ROOT + '/src/libvfcinstrument/.libs/libvfcinstrument.so'
mcalib_dir = PROJECT_ROOT + '/src/libmca-mpfr/'
vfcwrapper = PROJECT_ROOT + '/src/vfcwrapper/vfcwrapper.c'
llvm_bindir = "@LLVM_BINDIR@"
clang = llvm_bindir + '/clang'
opt = llvm_bindir + '/opt'
dragonegg = "@DRAGONEGG_PATH@"
gcc = "@GCC_PATH@"
FORTRAN_EXTENSIONS=[".f", ".f90", ".f77"]
C_EXTENSIONS=[".C", ".c", ".cpp", ".cc", ".cxx"]

class NoPrefixParser(argparse.ArgumentParser):
    # ignore prefix autocompletion of options
    def _get_option_tuples(self, option_string):
        return []

def is_fortran(name):
    return os.path.splitext(name)[1] in FORTRAN_EXTENSIONS

def is_c(name):
    return os.path.splitext(name)[1] in C_EXTENSIONS

def parse_extra_args(args):
    sources = []
    options = []

    for a in args:
        if is_fortran(a) or is_c(a):
            sources.append(a)
        else:
            options.append(a)

    return sources, ' '.join(options)

def fail(msg):
    print(sys.argv[0] + ': ' + msg, file=sys.stderr)
    sys.exit(1)

def shell(cmd):
    try:
        subprocess.check_call(cmd, shell=True)
    except subprocess.CalledProcessError:
        fail('command failed:\n' + cmd)

def linker_mode(sources, options, output, args):
    shell('{clang} -c -O2 -static -o .vfcwrapper.o {vfcwrapper} -I {mcalib_dir}'.format(
        clang=clang,
        vfcwrapper=vfcwrapper,
        mcalib_dir=mcalib_dir))

    if args.static:
        shell('{linker} {output} {options} {sources} -static .vfcwrapper.o {mcalib_dir}/.libs/libmcampfr.a -lmpfr -lgmp -lm -lgfortran'.format(
            linker=clang,
            output=output,
            sources=' '.join([os.path.splitext(s)[0]+'.o' for s in sources]),
            options=options,
            mcalib_dir=mcalib_dir))
    else:
        shell('{linker} {output} {options} {sources} .vfcwrapper.o -rpath {mcalib_dir}/.libs -L {mcalib_dir}/.libs -lmcampfr -lgfortran'.format(
            linker=clang,
            output=output,
            sources=' '.join([os.path.splitext(s)[0]+'.o' for s in sources]),
            options=options,
            mcalib_dir=mcalib_dir))

def compiler_mode(sources, options, output, args):
    for source in sources:
        basename = os.path.splitext(source)[0]
        ir = basename + '.1.ll'
        ins = basename + '.2.ll'

        # Compile to ir (fortran uses gcc+dragonegg, c uses clang)
        if is_fortran(source):
            shell('{gcc} -c -S {source} {options} -fplugin={dragonegg} -fplugin-arg-dragonegg-emit-ir -o {ir}'.format(
                gcc=gcc,
                source=source,
                options=options,
                dragonegg=dragonegg,
                ir=ir))
        else:
            shell('{clang} -c -S {source} -emit-llvm {options} -o {ir}'.format(
                clang=clang,
                source=source,
                options=options,
                ir=ir
            ))

        # Limit instrumentation to a function ?
        selectfunction = ""
        if args.function:
            selectfunction = "-vfclibinst-function " + args.function

        # Apply MCA instrumentation pass
        shell('{opt} -S -load {libvfcinstrument} -vfclibinst {selectfunction} {ir} -o {ins}'.format(
            opt=opt,
            libvfcinstrument=libvfcinstrument,
            selectfunction=selectfunction,
            ir=ir,
            ins=ins
            ))

        if not output:
            output = '-o ' + basename + '.o'
        # Produce object file
        shell('{clang} -c {output} {ins} {options}'.format(
            clang=clang,
            output=output,
            ins=ins,
            options=options))

if __name__ == "__main__":
    parser = NoPrefixParser(description='Compiles a program replacing floating point operation with calls to the mcalib (Montecarlo Arithmetic).')
    parser.add_argument('-c', action='store_true', help='only run preprocess, compile, and assemble steps')
    parser.add_argument('-o', metavar='file', help='write output to <file>')
    parser.add_argument('--function', metavar='function', help='only instrument <function>')
    parser.add_argument('-static', '--static', action='store_true', help='produce a static binary')
    args, other = parser.parse_known_args()

    sources, llvm_options = parse_extra_args(other)

    # check input files

    if len(sources) > 1 and args.o:
        fail('cannot specify -o when generating multiple output files')

    output = "-o " + args.o if args.o else ""
    if args.c:
        if len(sources) == 0:
            fail('no input files')
        compiler_mode(sources, llvm_options, output, args)
    else:
        if len(sources) == 0 and len(llvm_options) == 0:
            fail('no input files')
        compiler_mode(sources, llvm_options, "", args)
        linker_mode(sources, llvm_options, output, args)
